파이썬 공부

유튜브 : https://www.youtube.com/watch?v=kWiCuklohdY
블로그 : https://nadocoding.tistory.com/

---------------------------------------------------------------------------------------------------------
20210829 
정수가 print에서 + 사이에 쓰기이 위해서는
str(정수) 로 해주어야 한다. 정수를 문자형으로 바꿔줌

긴문장 주석처리 ''' 뭐시기~ '''
또는 주석이 필요한 부분 선택하고 ctrl + / 

연산자 제곱 2**3 = 2^3
몫 구하기 5//3 = 1

and (=&)   /  or(=| )
 
절댓값 : abs()
제곱   pow(a,b)  = a^b
최댓값, 최솟값   max(a,b)  or min(a,b)
반올림  round()



math 라이브러리 이용
from math import *    //math 라이브러리의 모든건 활용
floor() 내림
ceil() 올림
sqrt() 제곱근


///////랜덤함수///////

from random import *

print(random())    //0.0 ~ 1.0미만의 임의의 값 생성
곱셈,덧셈 등 사칙연산을 통해 범위 조정 가능
더 나아가 소숫점 없애기 => 정수형

int(random()) 하면 됨


+ randrange(a,b)   a부터 b 미만의 범위의 임의의 정수(int)값 생성 (끝 포함 안함)  
+ randint(a,b) a,b 사이의 임의의 값 , a,b도 포함  (자료형은 int)


random 모듈의 shuffle 과 sample

from random import *


lst = [1,2,3,4,5]
shuffle(lst)  : 순서 섞기
print(lst)
print(sample(lst,1))  : 랜덤으로 하나 뽑기



//////////문자열 길게 받기
""" ㅇㄹ다ㅡㄹㅈ
 ㄹ다ㅡㄹ ㅣㅏ 
 ㄷ라 드ㅜ '''


슬라이싱 (필요한 정보만 자르기)

jumin ="123456" 
  시작은 0부터 시작
 => jumin[원하는 값]

+ 받아올 때 범위도 가능  jumin[0:2]  0번째 부터 2직전 까지 => 0,1 출력
                                jumin[3:]  3부터 끝까지
  뒤에서부터 가능
   => -로 표현  => jumin[-7:] 뒤에서 7번째 부터(맨 마지막 문자를 -1로 두고 시작) 끝까지 (출력 순서는 앞에서 뒤로 방향 이전과 똑같음)

   : 이는 리스트 형태의 jumin 이라도 가능





문자열 처리함수
 => 모두 소문자로

python = "Python is Amazing"
python.lower() => 모두 소문자로 표현됨 
python.upper() => 모두 대문자
python[원하는 구간].isupper()   => 대문자인지?    => 변수에 따른 대소문자 변환 => 이후 읽어서 다음단계 어떻게 할 것인 지 결정하는 알고리즘

len(python)   => 길이

특정 문자만 바꾸기 
python.replace("Python","Java")   => 특정 문자 지우기도 가능 python.replace("Python", "")

index = python.index("n")  : 몇번째 위치해 있는지 (맨 처음 0번부터 시작)   #리스트 형태도 가능
print(index)  =>5
index = python.index("n", index+1)  6번쨰 위치부터 그 뒤에 n 이 몇번째 있는지 (순서는 맨 처음부터 시작) 

python.find("n")  : n이 몇번째?
python.find("Java") = -1 로 나옴 즉 없다는 뜻,   python.index("Java") => 에러남


python.count("n") : n이 총 몇번?


문자열 합침(+) , 문자열 사이 콤마(띄어쓰기)
//////////////문자열 포멧

print("나는 %d살 입니다." % 20)  %d :  정수
              %s  %문자열, 정수도 가능
              %c  % 문자 하나

값 두개?
  print("나는 %s와 %s를 좋아한다. " %(나, 가)

  print(" 나는 {}입니다.".format(20))  
          " 나는 {}와 {}를 좋아함.".format("나","가")
           " 나는 {0}와 {1}를 좋아함.".format("나","가")  =>숫자 이용해서 바꾸어서 입력 가능

print("나는{age}살이며, {color}색을 좋아함.".format(age=20,color="빨간"))



파이썬3.6이상 =>    
age =20
color ="빨간"
print(f"나는 {age}살이며, {color}색을 좋아한다.")

앞에 f를 이용해 print 에서 실제 변수값 이용 가능


//////////탈출문자
print("백문의 불여일견 \n 백견이 불여일타"       \n : 줄바꿈

print("저는 '나도코딩'입니다" ) 가능 
이떄 탈출문자 사용
print("저는\"나도코딩\"입니다.")   =>  \" or \'는 문장 내에서 따옴표로 사용 가능

\\역슬러쉬 두번 => \하나 출력


\r : 커서를 맨 앞으로 이동해서 덮어 씌운다.
print("Red Apple\rPine")  => PineApple

\b 백스페이스 (한글자 삭제) =>한글자 앞으로 이동후 덮어씌움

\t: 탭


((((((((((((((((((((((((((((((((((((((((((((((((((((((20210830))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))



//리스트
: 순서를 가지는 객체의 집합  (단어 가능)
(배열과 유사 )


subway = ["a","b","c"]  # " "를 씌워주어서 문자열로 저장해야 한다.

  => 활용   => a,b,c의 위치를 찾을 수 있음  // 그냥 [a b c] 로 집어넣으면 오류뜸 이유: a,b,c가 각각 변수로 저장되어서 초기화 되어있지 않음
 subway.index("a") = 0

  + 더하기 가능
subway.append("d")
 =>  [a,b,c,d]
   append는 맨 뒤에 붇는다

특정 영역에 집어넣음 가능

subway.insert(1,"e")   => 1번 자리에 추가 후 나머지는 뒤로 밀음 , 1과 e 순서 바뀜 조심)
 => [a,e,b,c,d]


특정 영역을 없애기 가능

subway.pop() : 맨 뒤에 뺀다
subway.pop(번호) : 해당 번호에 해당하는 부분 지움 (맨 앞 0부터 시작)

같은 변수가 몇개 있는지 ?

subway.count("a") =1


정렬도 가능
num_list = [5,4,2,3,1]
num_list.sort()
 = [1,2,3,4,5]

(앞뒤 순서바꿈) 
num_list.reverse()
 = [5,4,3,2,1,]

모두 지우기
num_list.clear()
 = []

*******리스트는 다양한 자료형과 함께 사용 가능

리스트 확장
num_list.extend(mix_list) <or> num_list+mix_list
 리스트 두 개가 이어짐


///////////사전  key 와 value

cabinet ={3:"유재석", 100:"김태호"}
print(cabinet[3]) = 유재석
print(cabinet.get(3)) : 위와 똑같은 값을 가져오는 방법


주의 
 print(cabinet[5])
 print("hi") 
  => 오류 뜨고 hi 안나옴  오류뜨고 프로그램 종류
  get은 None이라 뜨고 종료되지는 않음 


 key가 있는지 확인하는 방법 T or F
 print(3 in cabinet)  = True
 
 열쇠의 이름은 다양하게 가능
  예를들어 "A-3 도 key 이름으로 가능


 새롭게 넣기
 cabinet[c-30] = "조세호" 
  만약 이미 있는 키에 value 집어넣으면 덮어 씌워지게 된다

 key 지우기

 del cabinet["key "]

 key 들만 출력
 print(cabinet.keys())
 vlaue 들만 출력
 print(cabinet.values())

 쌍으로 출력
print(cabinet.items())

 모두 지우기
cabinet.clear()


////튜플 (변경되지 않는 리스트, 속도 빠름)   ''''''리스트는 대괄호, 튜플은 소괄호''''''''''

menu =("돈까스", "치즈까스")
print(menu[0]) 등과 같이 출력

menu.add( ) 불가능


name, age, hobby =("김종국", 20,"코딩")    # 괄호 빼도 가능
다음과 같이도 가능


((((((((((((((((((((((((((((((((((((((((((((((((((((((((((20210901))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

 문자열=" " 
 리스트 []
 튜플( , ) 순서0 
 사전 {key : value } 
 집합 { } 순서x 



//집함 (set) : 중복 안되고, 순서 없음

my_set = {1,2,3,3,3}
print(my_set) = 1,2,3

집합 정의방법
{} or set([]) :리스트로 만들고 set으로 감싸줌   # 나중에 리스트 정보를 집합으로 만들어 사용 가능

java = {"a","b","c"}
python =set(["a","d"])

교집합

print(java & python) = {'a'}       ( =   print(java.intersection(python))   )


합집합
 print( java | python)                (  =  print(java.union(python)    )


차집합  (java 0     /  python  x  )
print (java-python)   print(java.differrence(python))


집합에 원소 추가
python.add("김태호")

집합에 원소 삭제
java.remove("a")  






/////////자료구조 변경/////////////////////////////////////
menu = {"커피", "우유","주스"}
print(menu, type(menu))   => {'커피', '우유', '주스'} <class 'set'>   집합 클래스 :    { }

menu = list(menu)
print(menu, type(menu))   =>   ['주스', '우유', '커피'] <class 'list'>  리스트 클래스 :   [ ]

menu = tuple(menu) 
print(menu, type(menu))   =>  ('주스', '커피', '우유') <class 'tuple'>  튜플 :    ( )
 

 
/////숫자 생성////////////////////////////////////////////
            range(1,21)  1부터 21전까지(20포함하기 까지) 숫자 생성   => 이후 앞에 형태변환(ex, list,set,tuple, 등을 이용해서 형태 변환 후 활용 가능)



users = range(1,3)
print(users)                    : 오류   (이유: tpye(users) 하면 type 이 range라고 나와서 list에 있는 기능을 못씀

리스트 내에 있는 정보 접근 (  type은 리스트이므로  '그 정보[해당 영역 숫자]' 로 변환해주어야 읽음 가능  )

one = sample(users,1)  # users에서 1개 뽑음
users.pop(one[0]-1)
print(str(one[0]))  = 정수  나오고   //// print(one) =[정수] 이렇게 나옴 (type이 리스트임)       
print(users)

+ 받아올 때 범위도 가능  jumin[0:2]  0번째 부터 2직전 까지 => 0,1 출력
                                jumin[3:]  3부터 끝까지
  뒤에서부터 가능
   => -로 표현  => jumin[-7:] 뒤에서 7번째(맨 뒤 단어를 1번째로 놓고) 부터 끝까지 (순서는 앞에서 뒤로 방향 이전과 똑같음)

   : 이는 리스트 형태의 jumin 이라도 가능




random 함수의 shuffle 과 sample(원하는 문서, 랜덤으로 뽑고자 하는 개수)

shuffle = shuffle(lst) 를 하면 오류   그냥 shuffle(lst)만 써주면 알아서 섞여짐


리스트 출력 쉽게
예를들어 
print("커피 당첨자 : {0}".format(three))  와 같이 {0} 하나에 three(:원소 3개 리스트) 를 한번에 출력 가능


//////분기(if)
if 조건: 
   실행명령문
elif 조건:
   실행명령문
else:
   실행명령문


  조건 내에 or , and 삽입 가능


weather = input("오늘 날씨는 어떄요? ")      input 내 출력되고 입력 받음


입력 받을 때, 입력값을 형태변환도 가능
temp = int(input("기온은?"))



///////반복문 (for)////////////////////////////////
<구조>
for 변수 in 범위:
    내부 반복문(여기서 변수의 변화를 이용한 코드)




for 변수 in [0,1,2,3,4]:
     print("대기번호 : {0}".format(변수))

결과 :
대기번호 : 0
대기번호 : 1
대기번호 : 2
대기번호 : 3
대기번호 : 4



for 변수 in range(5):  #0,1,2,3,4 범위 생성됨   range(1,6)  = [1,2,3,4,5]
 
 다음과 같이 참조도 가능(f이용)  
ex1) for num in range(5):
         print("num : "+str(num))   # int형을 print에서 + 형태로 집어넣어서 출력하려면 str()을 씌워줘야함. 그냥 int 하나 출력은 str 없어도 되지만.
 
ex2) for num in range(5):
         print(f"num : {num} ")



starbucks = ["a","b","c"]
for customer in starbucks:
   print("{0}, 커피가 준비되었습니다.".format(customer))


///////반복문 while////////////////////////////////////////////////////

외부에서 조건 내 변수 초기화(=초기값 부여)
이후
while 조건:
   실행문장 
   조건 내 변수 계산처리
   if(조건 내 변수)
      실행문장

 조건을 만족하지 않으면 while 문을 빠져나감

ex) 

customer = "E"
index = 5
while index >=1:
   print(" {0} 손님 , {1} 번 남았습니다".format(customer,index))
   index -=1
   if index==0:
     print("폐기 처분하였습니다.")

**************python은 unexpected indentation 이 자주 뜬다(문장 앞에 공백 오류) 앞에 공백을 지워주거나 넣어주거나 해야함

무한 루프
while True:
   실행문장
 
   => 종료하려면 ctrl + C


원하는 입력이 올 때까지 반복

customer = "A"
person = "Unknown"

while person!=A:
   print("{0}, 준비되었음".format(customer))
   person = input("이름이 뭐임?")
print("여기 있다")


(((((((((((((((((((((((((((((((((20210902))))))))))))))))))))))))))))))))))))))))))))))))))
 
//////continue 와 break    (반복문 내에서 사용)//////////////////////////////

continue : 반복문 안에서 밑에있는 문장 실행하지 않고 다음 반복문 차례로 넘김


ex) 마치 필터처럼 걸러진다. => 이 구조를 이미지로 이해해서 활용하자. 흐르는 변수 속에 특정 변수를 발견하면(변수 in 특정변수들 )이면 특수한 행동을 하도록 한다.
absent = [2,5]    # 집합으로도 해도 됨, 튜플로 해도 됨    
for student in range(1,11):
    if student in absent:
       continue
     print("{0}번 있음".format(student))
      
결과:  
1번 있음
3번 있음
4번 있음
6번 있음
7번 있음
8번 있음
9번 있음
10번 있음

***********변수 in 범위   : 변수가 범위에 해당하는가?   => True or False 로 출력    
***********for 변수 in 범위  : 변수에 범위 내에 있는 정보를 순서대로 하나씩 부여하여 맨 끝 정보까지 변하면서 아래 쓰여있는 정보들을 실행시킴
***********key in 사전 : 사전 type에서 key가 사전 안에 있는가?

break : 반복문 중단


absent = [2,5]
error = [7]
for student in range(1,11):
   if student in absent:
      continue
   elif student in error:
      print("{} 번 에러 멈춤".format(error))
      break
   print("{0}번 있음".format(student))

      
결과 
1번 있음
3번 있음
4번 있음
6번 있음
[7] 번 에러 멈춤


/////////////////한줄 for문//////////////////////////////
<구조>

변수 = [계산처리 for 변수 in 범위]  
범위에 따라 계산처리 된 것들이 하나하나 list형태로 이어붙어진다.


# 출석번호가 1 2 3 4 앞에 100을 붙이기로 함 => 101,102,103,104 ...

students = list(range(1,6))
print(students)
students= [i+100 for i in students]  #students 에서 앞에서 부터 정보를 하나씩 꺼내와서 i(=그 값)+100한 값을 list형태로 students에 집어넣어라  ## list 괄호를 전체적으로 씌워야 한다.
print(students)


+++++++++++++++++++++궁금점 해결+++++++++++++++++++++++++++++++
의문 :
range값의 type은 range이다. 그래서 앞에서 부터 부여되는 0,1,2,3.... 순서에 해당하는 공간에 있는 값을 받아와서 출력하려면
예를들어 
num_list = range(1,6) 
print(num_list[0부터 시작하는 번호 이름중 원하는 정보가 들어있는 공간의 번호] )
를 해 주어야 그 공간안의 값이 출력이 된다.   => 변수[ ] 형태처럼 [ ]로 참조 가능한 정보는 , 1. 문자열, 2.리스트 3. 튜플, 4. range
그래서 위의 식을 


students = range(1,6)
print(students)
로만 해주면 결과 값이
range(1,6)
으로 나올 뿐이다.

공간 안에 있는 정보를 보여주려면
studens = list(range(1,6))
print(students)
를 해주어야 결과값이 
[1, 2, 3, 4, 5]
가 나온다.

하지만 for 문 안에서는 원하는 현재 순서에 해당하는 공간 안에 있는 정보를 읽는 데에 range로 만도 가능하다는 것을 보여준다.
예를들어
students = range(1,6)
print(students)
students= [i+100 for i in students]  #students 에서 앞에서 부터 차례로 값를 하나씩 꺼내와서 i(=그 값)+100한 값을 list형태로 students에 집어넣어라
print(students)

로 작성하고 결과값을 보면
range(1, 6)
[101, 102, 103, 104, 105]
다음과 같이 출력된다.
이는 for 문 안에서 students에 들어있는 각 공간안의 정보를 잘 뺴와서 더하고 리스트로 만들어 저장했다는 것을 보여 준다.


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#학생 이름을 길이로 변환
students =["Iron man","Thor","Mynameis"]
students = [len(i) for i in students]
print(students)

#학생 이름을 대문자로 변환
students =["Iron man","Thor","Mynameis"]
students = [i.upper() for i in students]
print(students)


(((((((((((((((((((((((((((((((((((((((((((((((((((((((20210903))))))))))))))))))))))))))))))))))))))))))))))))))))))))

////////////함수///////////////////////////

def 함수이름():                       //전달,반환값 없는 함수
    함수내 실행 문장


def 함수이름(전달값):   
   함수 내 실행문장
    return 반환값(여러개 반환해주고 싶으면 ',' 이용해 구분한다)


=> 생성 한 후
함수이름()을 적어 주어야 함수 실행


----------------함수 example code---------------------------------

def acccount():
    print("계좌 생성")


def deposit(balance, money):   #입금
    print("입금 완료. 잔액 {0}원".format(balance+money))
    return balance+money



def withdraw(balance,money):  #출금
    if balance >=money:
        print("출금 완료, 잔액 : {0}원".format(balance-money))
        return balance-money
    else:
        print("출금 불가, 잔액 : {0}".format(balance))
        return balance


def withdraw_night(balance,money):
    commission = 100  #수수료 100원
    return commission,balance-money-commission


balance = 0

balance = deposit(balance,1000)
balance = withdraw(balance,200)
commission, balance = withdraw_night(balance,500)
print("수수료 {0}원, 잔액 {1}원".format(commission,balance))

출력

입금 완료. 잔액 1000원
출금 완료, 잔액 : 800원
수수료 100원, 잔액 200원
--------------------------------------------------------------------------

//////////////함수 기본값/////////////////////////////////////////

문장이 길 때 보기 한 눈에 보기 좋도록 하는 방법
\(역슬레쉬)를 치고 enter를 하면 위의 한 문장이 2개의 줄로 보인다.
ex)
def profile(name,age,main_lang):
    print("이름:{0}\t나이 : {1}\t주 사용 언어: {2}"\
        .format(name,age,main_lang))
  

함수 기본값: 변 수 사이 공통된 값들은 함수 선언 때 미리 기본값을 부여해 변수 를 줄인다

ex)
#만약 같은 학교 같은 학년 같은 반 같은 수업이면? => 불필요한 변수 줄여줌(공통적인것)

def profile(name,age=17,main_lang="파이썬"):
    print("이름:{0}\t나이 : {1}\t주 사용 언어: {2}"\
        .format(name,age,main_lang))

profile("유재석")
profile("김태호")

결과
이름:유재석     나이 : 17       주 사용 언어: 파이썬
이름:김태호     나이 : 17       주 사용 언어: 파이썬

//////////////////////함수 키워드값 /////////////////////////////////////////

전달값을 받는 함수(순서 고려)를 선언해 놓고(함수 기본값과 달리)

이후에 그 함수를 사용할 때, 

키워드에 해당하는 
전달값들을 초기화 해주면 (전달값="원하는 전달값", 등등) 순서에 맞게 전달값에 값이 전달된다.

def 함수이름(전달값 등등)
     함수 내부 실행코드

함수 내부 실행코드가 순서에 맞게 실행이 된다.
이때 전달값을 줄 때, 순서는 고려하지 않고 이름만 맞춰서 집어넣어주면 알아서 변수에 맞게 출력이 된다.

-----------------------ex)----------------------------------------------------
#키워드값
def profile(name,age,main_lang):
    print("이름 :",name,"나이:",age,"주 언어",main_lang)


profile(name="유재석",main_lang="파이썬",age=20) # 순서 뒤죽박죽이어도 각 원하는 변수에 값이 부여된다.


결과:
유재석 20 파이썬
----------------------------------------------------------------------------

//////////////////////함수 가변인자를 이용한 함수 호출////////////////////////////////////

++++++++print문에서 
print(뭐시기)
print(더시기)
하면 뭐시기와 더시기는 줄바꿈이 되어 두줄로 출력된다.
print는 출력한 이후에 줄바꿈을 하기 때문 = > 줄바꿈을 하고 싶지 않다면

print(필요한 print문, end=" ")
print(필요한 print문, end=" ")
print(필요한 print문, end=" ")
...
처럼 , end=" "을 추가시켜주면 된다.


가변인자는 몇개를 받아 올 지 모르는 변수의 개수를 정해놓지 않고 같은 성질을 띠는 이름만 정해놓고
 그때그때 받아오는 만큼 생성하는 가변 변수이다.

그래서 함수 선언을 할 때

def 함수 이름(전달값,등등,*가변인자)
      함수 내 가변인자 받아온 것을 처리하기 위한 for 문(ex for i in 가변인자) 작성

와 같이 인자 앞에 *를 붙여준다.

=> 함수에 있는 앞에 전달값들을 모두 받아온 이후 들어오는 추가적인 입력들을 가변인자 속에 차례로 이어붙여서 하나의 " list 형태" 로 만들어 놓고 이를 for in 문을 통해 꺼내서 사용한다.)

----------------example----------------------------------------------
#가변인자를 이용한 함수 호출
"""
def profile(name, age, lang1,lang2,lang3,lang4,lang5):
    print("이름 : {0}\t나이 : {1}\t".format(name,age), end=" ")
    print(lang1,lang2,lang3,lang4,lang5)

profile("유재석",20,"Python","Java","C","C++","C#")

profile("김태호",25,"Kotlin","Swift","","","")
"""
#위와 같이 하면 쓰지않는 변수들이 생기거나, 
# 또는 추가적으로 필요한 변수들이 필요할 수 있음

#가변인자 활용
def profile(name,age,*language):
    print("이름 : {0}\t나이 : {1}\t".format(name,age), end=" ")
    for lang in language:
        print(lang,end=" ")   #줄바꿈 없이 lang 모두 출력
    print() #줄바꿈 용도

profile("유재석",20,"Python","Java","C","C++","C#","JavaScript")

profile("김태호",25,"Kotlin","Swift")


출력
이름 : 유재석   나이 : 20        Python Java C C++ C# JavaScript 
이름 : 김태호   나이 : 25        Kotlin Swift 


----------------------------------------------------------------------------


////////////////////////지역변수와 전역변수//////////////////////////////////////////////

gun =10

def checkpoint(soldiers):  #경계근무
    gun = gun-soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))

print("전체 총: {0}".format(gun))
checkpoint(2) #2명 경계근무
print("남은 총 : {0}".format(gun))

다음과 같은 코드는 다음과 같은 오류가 난다.
Traceback (most recent call last):
  File "c:/Users/gypsi/OneDrive/바탕 화면/python_basic/function_4.py", line 10, in <module>    checkpoint(2) #2명 경계근무
  File "c:/Users/gypsi/OneDrive/바탕 화면/python_basic/function_4.py", line 6, in checkpoint
    gun = gun-soldiers
UnboundLocalError: local variable 'gun' referenced before assignment

지역변수 gun이 assignment(초기화=변수에 초기 값을 부여해줌)전에 referenced(참조=사용) 되었기 때문에 오류가 났다. (함수 내부에서 변수 초기화가 되지 않았음)
즉 외부에 gun=10을 선언해 놓아도 
함수 내부에서는 그것을 쓰지 못하기 때문에 함수 내부에 따로 선언을 해 주어야 한다.


=> 수정해보자----------------------------------

gun =10

def checkpoint(soldiers):  #경계근무
    gun=20
    gun = gun-soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))

print("전체 총: {0}".format(gun))
checkpoint(2) #2명 경계근무
print("남은 총 : {0}".format(gun))

출력:

전체 총: 10
[함수 내] 남은 총 : 18
남은 총 : 10


-------------------------------------------------

이것을 보니 외부(전역공간)의 gun=10은 건드려 지지 않고 함수 내부 gun=20은 외부의 gun에 영향을 끼치지 않았다는 것이다.

그러면 외부 전역변수 gun=10을 함수 내부에서 사용(참조)하지 못하는 것인가?
이것을 전역변수를 사용하겠다는 global 형을 사용해 해결 할 수 있다.




=>수정해보자------------------------------

gun =10

def checkpoint(soldiers):  #경계근무
    global gun  #전역 공간에 있는 gun 사용
    gun = gun-soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))

print("전체 총: {0}".format(gun))
checkpoint(2) #2명 경계근무
print("남은 총 : {0}".format(gun))

출력:
전체 총: 10
[함수 내] 남은 총 : 8
남은 총 : 8

실제 gun이라는 값에 변화가 생겼다.

=> 외부에 선언되고 초기화된 변수를 함수 내부에서 사용하려면, 함수 내에서  'global 해당변수'를 선언해주고 나서 사용해야 한다.

-------------------------------------------------



c++에서 전역변수는 int main() {} 외부에서 변수를 초기화 해주면 된다

그럼 다른 것도 해보자
외부에서 gun 값을 받아오고 나서 gun 에 대한 사칙연산을 한 이후에 외붕 gun 값은 변할까?
=>코드는 다음과 같다-----------------
gun =10

def checkpoint(soldiers,gun):  #경계근무
      #전역 공간에 있는 gun 사용
    gun = gun-soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))

print("전체 총: {0}".format(gun))
checkpoint(2,gun) #2명 경계근무
print("남은 총 : {0}".format(gun))

출력:
전체 총: 10
[함수 내] 남은 총 : 8
남은 총 : 10
--------------------------------------
변하지 않은 것을 알 수 있다. 이는 c++에서도 많이 하는 main 함수 안에서 변수들의 처리들 
, 함수 내 변수의 휘발성과 같다고 볼 수 있다.

하지만 전역변수를 건드리는 것은 실제 상황에서는 위험하다.
그래서 return을 통해 원하는 값의 상태를 코드 밑으로 전달한다

--------최종 코드---------------------------------
gun =10

def checkpoint_ret(soldiers,gun):  #경계근무
      #전역 공간에 있는 gun 사용
    gun = gun-soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))
    return gun

print("전체 총: {0}".format(gun))
gun = checkpoint_ret(2,gun) #2명 경계근무, gun 변화한 것 return 을 통해 전체 gun 의 변화를 준다
print("남은 총 : {0}".format(gun))

출력:

전체 총: 10
[함수 내] 남은 총 : 8
남은 총 : 8


-----------------------------------------------------


++++++++++++소숫점 몇째자리까지? 표현하고, 반올림 할 것인가
=> round(값, 몇째자리 숫자)
-------------------------------------------------------


((((((((((((((((((((((((((((((((((((((((((((((21220120)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

///////////표준 입출력/////////////////

기존 print에서 ,는 띄어쓰기 // + 는 서로 붙여쓰기이지만 이를 sep=" "를 통해 관리 가능

print("Python","Java",sep=",") => 사이사이에 ,가 포함됨 

// end= " " 를 통해 print의 끝부분을 무엇으로 할 것인가? => 기본으로는 end="\n"으로 되어있어서 줄바꿈이 된다.

ex)
print("Python","Java",sep=",",end="?")
print("무엇?")

출력 =>  Python,Java?무엇? 
----------------------------------------------------------------------
import sys # sys 모듈을 가져와서 사용하겠다는 의미
print("Python", "Java", file=sys.stdout) # 표준 출력
print("Python", "Java", file=sys.stderr) # 표준 에러

출력 => 

Python Java
Python Java

큰 규모의 파이썬 프로젝트에서 보통 프로그램 수행 과정에서 몇 시에 어떤 작업을 어떤 식으로 수행하고 있으며
 그 결과는 어떠한지 등의 정보를 가지는 로그를 남길 때 
stdout 은 일반적인 내용을, 
stderr 는 에러 발생 시 관련 내용을 출력하기 위해 사용
=>  이렇게 구분지어주면 프로그램이 의도치 않은 동작을 하는 경우에 에러 로그만 확인하면 보다 빠르게 상황 파악 및 조치가 가능

----------------------------------------------------------------------
// 양 끝 정렬

# ljust(숫자), rjust(숫자) : 왼쪽 정렬+숫자만큼의 공간 확보 , 오른쪽 정렬+숫자만큼의 공간 확보

ex) 시험성적
scores = {"수학":0, "영어": 50, "코딩": 100}
for subject,score in scores.items():
    #print(subject,score)
    print(subject.ljust(8),str(score).rjust(4), sep=":") 
 
출력 => 
수학      :   0
영어      :  50
코딩      : 100
----------------------------------------------------------------------
# zfill(숫자) : 숫자만큼의 공간 확보하고, 남는 공간 0으로 채움

ex) 
# 은행 대기순번표
#001 , 002 , 003 ...
for num in range(1,21):
    print("대기번호 : "+str(num).zfill(3))

출력 => 
대기번호 : 001
대기번호 : 002
대기번호 : 003
대기번호 : 004
대기번호 : 005 ...
----------------------------------------------------------------------
#표준 입력
answer = input("아무 값이나 입력: ")  # 문자열 형태(str) answer에 저장됨


주의!
print("입력하신 값은 " + answer + "입니다.")
라고 할때
answer에 정수가 입력되어도 + 가 에러없이 잘 작동한다. (기존에는 int형 변수를 print 할 때에 + 를 사용하려면 str()을 씌워주어야 했다.)

그 이유는
아무 값이나 입력: 10
<class 'str'>
아무 값이나 입력: 그래
<class 'str'>

=> 10과 같은 정수도 str 타입이 되기 때문 /// 그냥 answer = 10 하면 type(answer) = <class 'int'> 이다.


--------------------------------------------------------------------------
#다양한 출력 포멧

빈 자리는 빈공간으로 두고, 오른쪽 정렬, 총 10자리 공간 확보 <=> {0: >10}

print("{0: >10}".format(500))   // >기호 왼쪽에 띄어쓰기 되어있음 =>빈공간을 띄어쓰기로 채움

[10칸 확보, 오른쪽 정렬] + 양수일 땐 + 로 표시, 음수일 땐 -로 표시 (+를 안적으면 양수일때는 그대로, 음수일 때는 -붙음)
print("{0: >+10}".format(500))
print("{0: >+10}".format(-500))

#왼쪽 정렬, 빈칸을 _로 채움
print("{0:_<10}".format(500))

# 3자리마다 콤마
print("{0:,}".format(100000000000)) # 3자리 마다 콤마 찍어주기
print("{0:+,}".format(100000000000)) # + 기호, 3자리 마다 콤마 찍어주기

# 복잡한 조합
빈 자리는 ^ 로, 좌측 정렬, + 기호, 30 칸의 공간 확보, 3자리 마다 콤마 찍어주기
 print("{0:^<+30,}".format(100000000000))

# 소숫점 출력
 print("{0:f}".format(5/3)) # 실수 값 출력 / 소숫점 6번째 자리 까지 (기본)
 print("{0:.2f}".format(5/3)) # 실수 값 출력 / 소숫점 2번째 자리 까지 (설정)

# 총정리
 print 내에서 
{인덱스:[[빈자리채우기]정렬][기호][확보공간][콤마][.자릿수][타입]}

-----------------------------------------------------------------------------
#파일입출력

프로그래밍에서 파일을 다룰 때는 일반적으로

1. 파일을 열고

2. 파일에 어떤 내용을 쓰거나 읽고

3. 파일을 닫는

순서로 진행


open("파일명", "열기 모드", encoding="인코딩")

"열기 모드" 에는 읽기(read, "r"), 쓰기(write, "w"), 이어쓰기(append, "a") 

=>  동일한 이름의 파일이 있는 경우 쓰기 모드는 그 파일을 덮어쓰게 되므로 기존 내용은 다 삭제가 되며, 
	이어쓰기 모드는 그 파일의 내용 맨 밑에 이어서 쓴다는 차이점
+ encoding 은 파일 내용으로 쓰는 언어와 관련된 것인데 일반적으로 "utf8" 로 설정을 해주면
  한글을 포함한 내용을 다룰 때에도 문제가 없음
+ 주의! 열었으면 꼭 닫아주어야 한다.


<쓰기>
score_file = open("score.txt", "w", encoding="utf8") # score.txt 파일을 쓰기("w") 모드로 열기
print("수학 : 0", file=score_file) # score.txt 파일에 내용 쓰기
print("영어 : 50", file=score_file) # score.txt 파일에 내용 쓰기
score_file.close() # score.txt 파일 닫기

<이어쓰기>
score_file = open("score.txt", "a", encoding="utf8") # score.txt 파일을 쓰기("a") 모드로 열기
score_file.write("과학 : 80")
score_file.write("\n코딩 : 100") # write 는 줄바꿈 안해주기 때문에 탈출문자(\n)로 줄바꿈 추가
score_file.close()

<읽기>
#read() 함수는 파일의 전체 내용을 한 번에 읽어오기
score_file = open("score.txt", "r", encoding="utf8") # score.txt 파일을 읽기("r") 모드로 열기
print(score_file.read()) # 파일 전체 읽어오기
score_file.close()

#readline() 함수를 이용하여 한 줄 단위로 불러오기
score_file = open("score.txt", "r", encoding="utf8")
print(score_file.readline(), end="") # 줄별로 읽기. 한 줄 읽고 커서는 다음 줄로 이동
print(score_file.readline(), end="") # 줄바꿈 중복을 방지하기 위해 end="" 처리
print(score_file.readline(), end="")
print(score_file.readline(), end="")
score_file.close()
=> 각 문장마다 end="" 를 통해 줄바꿈을 하지 않도록 처리
이유:  현재 파일에 쓰여진 각 문장은 끝에 줄바꿈을 포함하고 있기 때문에 print() 자체의 줄바꿈과 중복으로 실행되는 증상을 막기 위해서

#while문으로 더이상 읽으려는 줄이 없을 때 반복문 탈출

score_file = open("score.txt", "r", encoding="utf8")

while True:
    line = score_file.readline()
     if not line: # 더 이상 읽어올 내용이 없으면?
         break # 반복문 탈출
     print(line, end="") # 읽어온 줄 출력. 줄바꿈 중복을 방지하기 위해 end="" 처리
    
score_file.close()

# 파일 내용을 한 번에 불러와서 리스트에 저장해두고 리스트를 반복 순회하면서 내용을 출력
score_file = open("score.txt", "r", encoding="utf8")

lines = score_file.readlines()       # 모든 줄을 읽어와서 list 형태로 저장
# print(lines) => ['수학 : 0\n', '영어 : 50\n', '과학 : 80\n', '코딩 : 100'] 처럼 저장됨 
#  \n 이 나오면 다음 차례로 넘어간다.
for line in lines:
    print(line, end="") # 읽어온 줄 출력. 줄바꿈 중복을 방지하기 위해 end="" 처리
score_file.close()
-------------------------------------------------------------------------------------------------------------

((((((((((((((((((((((((((((((((((((((((20220121))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

<pickle>
프로그램은 실행이 끝나버리면 모든 데이터가 사라진다고 했으므로 끝나기 전에 어딘가 저장을 해야한다.
이 때 사용할 수 있는 것이 바로 pickle 이다. 
pickle 은 프로그램에서 사용하고 있는 데이터를 파일 형태로 저장하거나 불러올 수 있게 해주는 모듈.


pickle 이용해 데이터를 파일로 저장할때 dump() 함수 사용
dump(data, dest_file)

=> 첫 번째 전달값으로는 저장할 데이터를, 두 번째 전달값으로는 데이터를 저장할 파일

ex) 어떤 사람의 프로필 데이터를 만들고 저장

파일 형태 pickle => 
pickle 을 이용해서 저장되는 파일은 텍스트(text)가 아닌 바이너리(binary) 형태
일반적인 한글, 영어, 숫자 등의 내용을 담고 있는게 텍스트 파일 //  .jpg, .png 와 같은 이미지나 .mp3 와 같은 음악, 또는 .exe 와 같은 실행 파일 등이 바이너리 파일

pickle 로 저장하는 파일 또한 바이너리 파일이기 때문에 
open() 함수를 이용할 때 "w" 뒤에 "b" 를 붙여서 "wb" 라고 해야 올바르게 저장
+ 데이터 내에 한글이 포함되어 있다 하더라도 별도의 encoding 은 지정할 필요가 없음


import pickle # pickle 모듈 가져다 쓰기

profile_file = open("profile.pickle", "wb") # 바이너리(binary) 형태로 저장
profile = {"이름":"박명수", "나이":30, "취미":["축구", "골프", "코딩"]}
print(profile)

pickle.dump(profile, profile_file) # profile 데이터를 file 에 저장
profile_file.close()

pickle 형태로 저장한 파일에 지금 사용한 변수 초기화(profile) 내용을 pickle.dump(변수,저장장소)를 통해 저장해 주고 다 끝나면 파일 닫기

=> profile.pickle 파일이 생기고, 이후 정보를 불러오고 싶다면 load(저장파일) 을 통해 접근


profile_file = open("profile.pickle", "rb")   # 읽을 때에도 바이너리(binary) 명시
profile = pickle.load(profile_file)            # file 에 있는 정보를 불러와서 profile 에 저장

print(profile)
profile_file.close()

****** 의문점 => 저 profile을 저장하고 추가로 profile2라는 사전을 만들어서 profile_file에 저장하면 둘 다 나중에 불러 올 수 있는가?
=> profile2를 만들어서 dump를 통해 집어넣고 나중에 profile_file을 불러왔지만 처음 profile만 출력되었음
 => 추가로 저장이 안되나 봄

------------------------------------------------------------------------------------------------

<with>
파일 open 하고 close 안해도 된다 =>

with 작업 as 변수명:
    실행 명령문1
    실행 명령문2
    ... 

형태로 작업을 통해 파일을 열고(읽기, 쓰기, 이어쓰기 ) as 를 통해 변수명에 데이터 접근권을 넘긴 뒤
이후 실행 명령문을 통해 이 데이터를 출력하거나 한다.

아까 pickle 파일 만든것을 열고 안에 내용을 출력해보면
import pickle

with open("profile.pickle", "rb") as profile_file:
    print(pickle.load(profile_file))

출력 => {'이름': '박명수', '나이': 30, '취미': ['축구', '골프', '코딩']} 

ex) 파일 생성 및 출력

txt 생성
with open("study.txt", "w", encoding="utf8") as study_file:
    study_file.write("파이썬을 열심히 공부하고 있어요")


with open("study.txt", "r", encoding="utf-8") as study_file:
    print(study_file.read())

출력 => 파이썬을 열심히 공부하고 있어요 

----------------------------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<클래스>

형태=>

class 클래스명:
    def 메소드1(self, 전달값1, 전달값2, ...):
        실행명령문1
        실행명령문2
        ...

    def 메소드2(self, 전달값1, 전달값2, ...):
        실행명령문1
        실행명령문2
        ...

ex)  클래스 생성 및 사용 => 사용해서 만든 것 : 객체 ( 이 객체를 class의 instance라고 한다)

class Unit:
    def __init__(self, name, hp, damage):
        self.name = name # 멤버변수 name 에 전달값 name 저장
        self.hp = hp
        self.damage = damage
        print("{0} 유닛이 생성되었습니다.".format(self.name))
        print("체력 {0}, 공격력 {1}".format(self.hp, self.damage))


marine1 = Unit("마린", 40, 5) # 마린1 생성. 전달값으로 name, hp, damage 를 전달
marine2 = Unit("마린", 40, 5) # 마린2 생성
tank = Unit("탱크", 150, 35) # 탱크 생성

출력 => 
마린 유닛이 생성되었습니다.
체력 40, 공격력 5
마린 유닛이 생성되었습니다.
체력 40, 공격력 5
탱크 유닛이 생성되었습니다.
체력 150, 공격력 35


=> 형태 : 변수명 = 클래스명(전달값1, 전달값2, ...) # 전달값은 클래스의 __init__() 에 정의된 부분 중 self 를 제외한 값

정리:
클래스는 서로 관련이 있는 변수 (멤버변수) 와 함수 (메소드) 들의 집합
클래스 내에는 여러 개의 메소드를 정의할 수 있는데 각 메소드의 첫 번째 전달값 위치에는 self 를 적어야함
 __init__() 메소드를 통해 기본적으로 필요한 전달값들을 전달받고 self. 을 통해 클래스의 멤버 변수를 정의



----------------------------------------------------------------------------------------------------------------

<__init__()>
클래스에는 __init__() 메소드가 있음. 이를 생성자(Constructor) 라고 부른다, 
사용자가 따로 호출하지 않아도 클래스 객체를 생성할 때 자동으로 호출이 되는 부분.
객체를 생성할 때는 이 생성자의 전달값에 해당하는 갯수만큼 값을 던져줘야 합니다. (단, self 부분은 제외)

아까 클래스
class Unit:
    def __init__(self, name, hp, damage): # 3개의 전달값
        self.name = name
        self.hp = hp
        self.damage = damage
        print("{0} 유닛이 생성되었습니다.".format(self.name))
        print("체력 {0}, 공격력 {1}".format(self.hp, self.damage))

marine1 = Unit("마린", 40, 5)
marine2 = Unit("마린", 40, 5)
tank = Unit("탱크", 150, 35)
에서 전달값을 3개보다 적게 넘기면
marine3 = Unit("마린") # 전달값 3개 중 1개만 넘김 =>  TypeError: __init__() missing 2 required positional arguments: 'hp' and 'damage' 에러뜸

클래스 객체를 생성할 때는 __init__() 생성자에 정의된 self 를 제외한 갯수만큼 전달값을 넘겨주어야 한다.

-------------------------------------------------------------------------------------------------------------------

<맴버변수>

클래스 생성자나 메소드가 아닌 곳에서 멤버변수 정보를 출력
클래스 내에서는 self. 과 같이 멤버변수에 접근할 수 있었는데 
객체를 통해 접근할 때에는 객체 이름 뒤에 점(.) 을 찍고 멤버변수 이름을 적으면 된다.

ex)
# 레이스 : 공중 유닛, 비행기. 클로킹 (상대방에게 보이지 않음)
wraith1 = Unit("레이스", 80, 5) # 체력 80, 공격력 5
print("유닛 이름 : {0}, 공격력 : {1}".format(wraith1.name, wraith1.damage)) # 멤버변수 접근

출력 =>

레이스 유닛이 생성되었습니다.
체력 80, 공격력 5
유닛 이름 : 레이스, 공격력 : 5

우리편 다크 아칸이 레이스를 하나 빼았는다 가정
# 마인드 컨트롤 : 상대방 유닛을 내 것으로 만드는 것 (빼앗음)
wraith2 = Unit("빼앗은 레이스", 80, 5)

빼았는 유닛을 위한 특별한 멤벼변수 정의 , 이름은 cloaking 이라고 하고 True 일 땐 클로킹 상태, False 일 땐 일반 상태

wraith2.cloaking = True # 빼앗은 레이스만을 위한 특별한 멤버변수 정의

확인 =>
if wraith2.cloaking == True: # 클로킹 상태라면?
    print("{0}는 현재 클로킹 상태입니다.".format(wraith2.name))

 출력 => 빼앗은 레이스는 현재 클로킹 상태입니다.

* 우리가 만든 레이스의 클로킹 여부
if wraith1.cloaking == True: # 우리가 만든 레이스 클로킹 여부
    print("{0}는 현재 클로킹 상태입니다.".format(wraith1.name))

출력 =>AttributeError: 'Unit' object has no attribute 'cloaking' 
: 우리가 만든 wraith1 에서 아직 정의되지 않은 cloaking 변수에 접근을 하려다보니 에러

반면에 wraith2 는 클래스 외부에서 직접 cloaking 이라는 멤버 변수를 정의 => 잘 작동

****
이와 같이 클래스로부터 객체를 만든 다음 그 객체만을 위한 멤버 변수 정의가 필요한 경우에는
 클래스 외부에서 별도로 정의할 수 있으며,
 이 때 이 객체를 제외한 다른 객체들은 새로 정의된 멤버 변수를 알지 못하며 사용할 수도 없다. 
오직 이 객체만을 위한 멤버변수가 된다.
****
------------------------------------------------------------------------------------------------------
<메소드>

 이 때 유닛 이름과 공격력은 이미 클래스 객체의 멤버 변수로 정의되어 있기 때문에 자기 자신을 의미하는 self. 을 쓰고, 
공격 방향은 명령을 받을 때마다 달라질 수 있으므로 멤버 변수가 아닌 전달값을 사용하기 위해 self. 없이 쓴다는 점 주의


ex) 새로운 클래스를 정의하고 __init__() 생성자를 제외한 2개의 메소드를 추가로 정의한 후 각각 호출하기

self 는 자기 자신을 의미합니다. 
생성자 또는 메소드에서 self 를 전달받는 것은 결국 자기 자신을 받는다는 의미이며 메소드 내에서 self. 를 쓰는 것은 자기 자신의 멤버 변수 또는 메소드에 접근하겠다는 의미가 됩니다.
firebat1 은 AttackUnit 클래스의 인스턴스이며 코드상에서 객체를 생성할 때는 name, hp, damage 정보만 전달하지만 
자동으로 호출되는 __init__() 생성자의 처음 위치에 있는 self 에 자기 자신을 전달하는 것과 같습니다.
(self에 자기자신을 전달 하였으므로, '.'을 통해 내부 멤버변수 접근한다)
그래서 생성자 내에서 self.name = name 이라고 하는 것은 마치 firebat1.name = name 과 같은 동작이 되는 것입니다.

코드

class AttackUnit: # 공격 유닛
    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    def attack(self, location): # 공격 방향
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage)) # 공간이 좁아서 2줄에 걸쳐 출력

    def damaged(self, damage): # damage 만큼 유닛 피해
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage)) # 데미지 정보 출력
        self.hp -= damage # 유닛의 체력에서 전달받은 damage 만큼 감소
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp)) # 남은 체력 출력
        if self.hp <= 0: # 남은 체력이 0 이하이면?
            print("{0} : 파괴되었습니다.".format(self.name)) # 유닛 파괴 처리

# 파이어뱃 : 공격 유닛, 화염방사기. 
firebat1 = AttackUnit("파이어뱃", 50, 16) # 체력 50, 공격력 16
firebat1.attack("5시") # 5시 방향으로 공격 명령

# 공격 2번 받는다고 가정
firebat1.damaged(25) # 남은 체력 25
firebat1.damaged(25) # 남은 채력 0


요약
class내의 정보를 객체(받는 변수)에 전달함으로 인해, 객체가 class 내의 함수(메소드)를 사용할 수 있게 된다.
객체가 class내의 함수를 사용하려면 접근해야 하므로 '.'을 통해 접근하고 각 함수(메소드)에 전달해야할 전달값을 
함수를 실행 할 때 적절하게 전달해서 사용하면한다.

------------------------------------------------------------------------------------------------------------
<상속>
 클래스에는 상속이라는 개념이 있어서 공통되는 부분은 코드를 중복으로 적지 않고도 재사용을 할 수 있다.
  AttackUnit 클래스는 Unit 클래스의 name, hp 멤버변수를 포함하면서 
추가로 damage 멤버변수를 정의하고 있으므로
 Unit 클래스로부터 상속을 받으면 Unit 클래스의 name, hp 를 그대로 사용할 수 있다.

# 형태
class 자식클래스(상속받을 부모클래스):


ex)
# 일반 유닛
class Unit:
    def __init__(self, name, hp):
        self.name = name
        self.hp = hp

# 공격 유닛
class AttackUnit(Unit):
    def __init__(self, name, hp, damage):
        Unit.__init__(self, name, hp)
        self.damage = damage

    def attack(self, location):
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage))

    def damaged(self, damage):
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage))
        self.hp -= damage
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp))
        if self.hp <= 0:
            print("{0} : 파괴되었습니다.".format(self.name))

요약
공통되는 부분을 상위 클래스에 정리해 놓고, 이 정보를 모두 사용하는 하위 클래스를 만들 때
class 정의 부분의 전달값에 상위클래스를 전달시켜서 상속시켜준다.
이후 하위 클래스의 __init__() 메소드 부분에 전달값을 넘길때(이 전달값은 하위 클래스를 이용해 객체(instance)를 만들 때 전달해주어야 하는 전달값)
상위 클래스에서 정의한 멤버 변수도 포함하도록 전달값들을 마련해 놓고,
하위 클래스의 __init__(self,전달값들) 메소드에서 
상위클래스.__init__(self,전달값들) 을 적어놓는다.
이 흐름을 따라가보면
하위 클래스를 작동시키면(스위치를 켜면)
바로 실행되는 __init__ 매소드부분에 있는
상위클래스.__init__(self,전달값들)
를 통해 상위 클래스에도 불이 들어와 작동하게 되고
하위 클래스는 상위 클래스의 정보(멤버 변수, 상위 클래스에 있는 메소드들)를 모두 보고 사용할 수 있게 되며
하위클래스에서 이 상위클래스의 정보를 이용해 하위클래스 메소드를 다룰 수 있다.

---------------------------------------------------------------------------------------------------------------------
<다중상속>

형태 : 
class 자식클래스(부모클래스1, 부모클래스2, ...):


ex)

# 일반 유닛
class Unit:
    def __init__(self, name, hp):
        self.name = name
        self.hp = hp

# 공격 유닛
class AttackUnit(Unit):
    def __init__(self, name, hp, damage):
        Unit.__init__(self, name, hp)
        self.damage = damage

    def attack(self, location):
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage))

    def damaged(self, damage):
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage))
        self.hp -= damage
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp))
        if self.hp <= 0:
            print("{0} : 파괴되었습니다.".format(self.name))

# 날 수 있는 기능을 가진 클래스
class Flyable:
    def __init__(self, flying_speed): # 공중 이동 속도
        self.flying_speed = flying_speed

    def fly(self, name, location): # 유닛 이름, 이동 방향
        print("{0} : {1} 방향으로 날아갑니다. [속도 {2}]"\
            .format(name, location, self.flying_speed))

# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed): # 이름, 체력, 공격력, 공중 이동 속도
        AttackUnit.__init__(self, name, hp, damage) # 이름, 체력, 공격력
        Flyable.__init__(self, flying_speed) # 공중 이동 속도

# 발키리 : 공중 공격 유닛, 한번에 14발 미사일 발사.
valkyrie = FlyableAttackUnit("발키리", 200, 6, 5) # 이름, 체력, 공격력, 공중 이동 속도
valkyrie.fly(valkyrie.name, "3시") # 3시 방향으로 발키리를 이동


요약
여러개의 클래스를 상속받을 수 있음 => 당연히 상속 받고는 맨 하위 클래스의 __init__()메소드의 전달값들이
지금까지 상속받은 부모들에서 받아와야 하는 전달값들 (+ 하위 클래스에서 받아오고자 하는 새로운 멤버 변수)이 모두 포함되도록
해주어야 상속받은 클래스의 모든 불을 켜줄 수 있다.
마지막으로 최족적으로 class 정보를 온전히 받게된 객체(instance)에서 메소드를 접근할 때, 
융합된 모든 class의 멤버 변수들의 정보도  '.' 을 통해 접근 할 수 있게 된다.
클래스를 상속받으면 
하위 클래스는 상위 클래스의 __init__() 내의 정보를 모두 복사되어 하위클래스 __init__() 부분에 전달되고,
상위 클래스의 모든 메소드 들도 하위클래스에 복사해서 전달된다.
그러므로
valkyrie.fly(valkyrie.name, "3시")
에서 valkyrie.name="발키리" 가 가능한 이유는
 FlyableAttackUnit를 통해 생성되었을 때, 
__init__() 부분에서 상위 클래스를 통해 받아온 self.name이라는 것에 "발키리" 를 전달 했기 때문에
또 다른 클래스에서 상속받은 메소드(fly)에서 사용할 때,
 valkyrie(=self).name에 저장된 "발키리" 정보를
 fly를 실행하기 위해 넣어주어야 할 전달값인( 이름, 위치) 부분에 '이름' 부분으로써 전달 가능하다.

다른 메소드에서 상속받은 메소드를 사용하는 것을 더 자세히 정리해보면,
상속을 받고 => __init__()에서 상위 클래스의 __init__를 실행시켜 상위클래스의 모든 불을 켜고 
=>하위클래스에서 새로운 메소드를 정의한 다음
 => 그 매소드 내에서 상속받은 메소드를 쓰려면
=> 현재 클래스 내의 정보(현재 클래스 내에 상속받은 메소드들이 모두 들어있음)중에 메소드에 접근해야 하므로
=> self.원하는메소드(해당하는 전달값 ( 만약 객체를 만들때 전달했던 정보들 중에, 현재 메소드에 전달해야 할 정보(멤버 변수)가 있다면 self.필요한멤버변수 를 이용해 전달해 준다.)
------------------------------------------------------------------------------------------------------------
<메소드 오버라이딩>

 여기서는 Unit 클래스에 정의된 move() 메소드를 FlyableAttackUnit 클래스 내에서 오버라이딩 해본다. 
메소드 오버라이딩은 부모 클래스에 정의된 메소드를 
그대로 자식 클래스에서 동일한 이름과 동일한 전달값으로 하여 정의하면 됨.
 대신 메소드 동작만 원하는대로 변경하면 되는 것이죠.

# 일반 유닛
class Unit:
    def __init__(self, name, hp, speed):
        self.name = name
        self.hp = hp
        self.speed = speed

    def move(self, location):
        print("[지상 유닛 이동]")
        print("{0} : {1} 방향으로 이동합니다. [속도 {2}]"\
            .format(self.name, location, self.speed))

# 공격 유닛
class AttackUnit(Unit):
    def __init__(self, name, hp, speed, damage):
        Unit.__init__(self, name, hp, speed)
        self.damage = damage

    def attack(self, location):
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage))

    def damaged(self, damage):
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage))
        self.hp -= damage
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp))
        if self.hp <= 0:
            print("{0} : 파괴되었습니다.".format(self.name))

# 날 수 있는 기능을 가진 클래스
class Flyable:
    def __init__(self, flying_speed):
        self.flying_speed = flying_speed

    def fly(self, name, location):
        print("{0} : {1} 방향으로 날아갑니다. [속도 {2}]"\
            .format(name, location, self.flying_speed))

# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed):
        AttackUnit.__init__(self, name, hp, 0, damage)
        Flyable.__init__(self, flying_speed)

    def move(self, location):   <------------------------------------   #메소드 오버라이딩
        print("[공중 유닛 이동]")
        self.fly(self.name, location)   <--------------------------- #상속받은 메소드(Flyable의 fly(이름,방향) 사용

# 벌쳐 : 지상 유닛, 기동성이 좋음
vulture = AttackUnit("벌쳐", 80, 10, 20) # 지상 speed 10

# 배틀크루저 : 공중 유닛, 체력도 굉장히 좋음, 공격력도 좋음
battlecruiser = FlyableAttackUnit("배틀크루저", 500, 25, 3)

vulture.move("11시")
# battlecruiser.fly(battlecruiser.name, "9시")
battlecruiser.move("9시") # 오버라이딩된 move() 호출


## 하위 클래스 내에서 상속받은 클래스 정보를 사용하려면(이미 상속되여 하위 클래스에 존재) 
     => self.(원하는 멤버변수 or 원하는 메소드(전달값)) 를 통해 사용하고

   클래스 밖에서 클래스를 이용해 객체를 만든 후에는 (객체 = 클래스 를 이용해 클래스를 객체에 전달)
  객체에 class의 정보를 모두 담은 '이름' 이 전달되어 있으므로 
  객체.(원하는 멤버 변수 or 원하는 메소드(전달값) ) 형태를 통해 내부 정보에 접근 할 수 있다.

----------------------------------------------------------------------------------------------------------------
<pass>

이번에는 건물을 위한 클래스 만들기
이름과 체력,파괴됨 가능 => Unit 클래스 상속받으면됨

그런데 건물은 클래스를 정의하기는 하는데 __init__() 생성자의 세부 내용은 일단은 그냥 내버려 둔다.
다른 작업을 먼저 하고 나서 나중에 코드를 완성한다고 가정. 
이럴 때 파이썬에서는 pass 를 쓸 수 있음.

ex)

 건물
class BuildingUnit(Unit):
    def __init__(self, name, hp, location):
        pass

# 서플라이 디폿 : 건물, 1개 건물 = 8 유닛.
supply_depot = BuildingUnit("서플라이 디폿", 500, "7시") # 체력 500, 생성 위치 7시


여기서 pass 는 아무것도 하지 않고 일단은 그냥 넘어간다는 의미로 사용
=> 즉, __init__() 생성자는 실제로는 완성되지 않았지만 마치 완성된 것처럼 보여질 수 있음


pass 는 다른 곳에서도 사용이 가능

ex)
def game_start():
    print("[알림] 새로운 게임을 시작합니다.")

def game_over():
    pass

game_start()
game_over()

출력 =>  [알림] 새로운 게임을 시작합니다.

game_start() 함수에서는 정의된 동작을 수행하고 game_over() 함수에서는 pass 를 통해 그냥 넘어감

요약
: 함수 뿐 아니라 if, for, while 등에서도 pass 를 사용하여 당장은 세부 동작을 정의하지 않은 채로 뒀다가 
나중에 다시 코드를 완성하도록 할 수 있음.

--------------------------------------------------------------------------------------------------------------------------------
<super>

 앞에서 건물 유닛 클래스를 만들 때 pass 로만 남겨두었던 __init__() 생성자의 코드를 완성해보자.
Unit 클래스를 상속받았기 때문에 Unit 의 __init__() 을 활용하면 되는데, 
건물은 지상 이동을 할 수 없으므로 speed 정보는 0 으로 하고 다음 줄에서 location 멤버 변수를 정의

ex)
class BuildingUnit(Unit):
    def __init__(self, name, hp, location):
        Unit.__init__(self, name, hp, 0) # speed 0 : 건물은 지상 이동 불가
        self.location = location


이때,
클래스에서는 부모 클래스의 이름을 직접 적지 않고도 부모 클래스에 접근하는 방법이 있음
 : super() 사용 (단, super() 를 사용할 때는 self 를 제외한다는 점을 주의)

ex)
class BuildingUnit(Unit):
    def __init__(self, name, hp, location):
        super().__init__(name, hp, 0) # 부모 클래스 접근. self 없이 사용   <--------------super부분
        self.location = location


하지만 부모 클래스를 2개 이상 상속하는 다중상속의 경우
설명을 돕기 위해 새로운 파이썬 파일을 하나 생성

class Unit:
    def __init__(self):
        print("Unit 생성자")

class Flyable:
    def __init__(self):
        print("Flyable 생성자")

class FlyableUnit(Unit, Flyable):
    def __init__(self):
        super().__init__()    <------------super()를 통해 부모 클래스의 생성자(__init__()) 호출

# 드랍쉽
dropship = FlyableUnit()

출력 => Unit 생성자

: 분명 부모 클래스는 Unit 과 Flyable 인데 super() 를 통해 생성자를 호출했을 때 Unit 클래스의 생성자가 호출되엇음

==>이번에는 부모 클래스의 상속 순서를 Unit, Flyable 에서 Flyable, Unit 으로 바꿔보자

ex)
# class FlyableUnit(Unit, Flyable):
class FlyableUnit(Flyable, Unit): # 순서 변경
    def __init__(self):
        super().__init__()

출력 : Flyable 생성자
다시 실행해보니 이번에는 Flyable 클래스의 생성자가 호출


****즉, 다중 상속을 받은 클래스에서 super() 를 통해 부모 클래스로 접근을 할 때는 순서상 가장 먼저 상속받은 클래스로 접근***
그러므로 다중 상속을 할 때 모든 부모 클래스의 생성자를 호출하려면
 다음과 같이 명시적으로 각 부모 클래스의 이름을 통해서 접근해야 한다.

ex)
class FlyableUnit(Flyable, Unit):
    def __init__(self):
        # super().__init__()
        Unit.__init__(self) # Unit 클래스 생성자 호출
        Flyable.__init__(self) # Flyable 클래스 생성자 호출

출력 => 
Unit 생성자
Flyable 생성자

코드를 실행해보면 이번에는 두 부모 클래스의 생성자를 모두 호출

--------------------------------------------------------------------------------------------------------------------

<최종>

from random import *

# 일반 유닛
class Unit:
    def __init__(self, name, hp, speed):
        self.name = name
        self.hp = hp
        self.speed = speed
        print("{0} 유닛이 생성되었습니다.".format(name))

    def move(self, location):
        print("{0} : {1} 방향으로 이동합니다. [속도 {2}]"\
            .format(self.name, location, self.speed))

    def damaged(self, damage):
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage))
        self.hp -= damage
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp))
        if self.hp <= 0:
            print("{0} : 파괴되었습니다.".format(self.name))

# 공격 유닛
class AttackUnit(Unit):
    def __init__(self, name, hp, speed, damage):
        Unit.__init__(self, name, hp, speed)
        self.damage = damage

    def attack(self, location):
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage))

# 마린
class Marine(AttackUnit):
    def __init__(self):
        AttackUnit.__init__(self, "마린", 40, 1, 5) # 이름, 체력, 이동속도, 공격력

    # 스팀팩 : 일정 시간 동안 이동 및 공격 속도를 증가, 체력 10 감소
    def stimpack(self):
        if self.hp > 10:
            self.hp -= 10
            print("{0} : 스팀팩을 사용합니다. (HP 10 감소)".format(self.name))
        else:
            print("{0} : 체력이 부족하여 스팀팩을 사용하지 않습니다".format(self.name))

# 탱크
class Tank(AttackUnit):
    # 시즈모드 : 탱크를 지상에 고정시켜, 더 높은 파워로 공격 가능. 이동 불가.
    siege_developed = False # 시즈모드 개발여부 (클래스 변수)

    def __init__(self):
        AttackUnit.__init__(self, "탱크", 150, 1, 35) # 이름, 체력, 이동속도, 공격력
        self.siege_mode = False # 시즈모드 (해제 상태)
    
    # 시즈모드
    def set_siege_mode(self):
        if Tank.siege_developed == False: # 시즈모드가 개발되지 않은 경우 메소드 탈출
            return

        # 현재 시즈모드가 아닐 때
        if self.siege_mode == False:
            print("{0} : 시즈모드로 전환합니다.".format(self.name))
            self.damage *= 2 # 공격력 2배로 증가
            self.siege_mode = True # 시즈 모드 설정
        # 현재 시즈모드일 때
        else:
            print("{0} : 시즈모드를 해제합니다.".format(self.name))
            self.damage /= 2 # 공격력 절반으로 감소
            self.siege_mode = False # 시즈 모드 해제

# 날 수 있는 기능을 가진 클래스
class Flyable:
    def __init__(self, flying_speed):
        self.flying_speed = flying_speed

    def fly(self, name, location):
        print("{0} : {1} 방향으로 날아갑니다. [속도 {2}]"\
            .format(name, location, self.flying_speed))

# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed):
        AttackUnit.__init__(self, name, hp, 0, damage)
        Flyable.__init__(self, flying_speed)

    def move(self, location):
        self.fly(self.name, location)

# 레이스
class Wraith(FlyableAttackUnit):
    def __init__(self):
        FlyableAttackUnit.__init__(self, "레이스", 80, 20, 5) # 체력, 공격력, 공중 이동 속도
        self.cloaked = False # 클로킹 모드 (해제 상태)

    # 클로킹 모드
    def cloaking(self):
        # 현재 클로킹 모드일 때
        if self.cloaked == True:
            print("{0} : 클로킹 모드 해제합니다.".format(self.name))
            self.cloaked = False
        # 현재 클로킹 모드가 아닐 때
        else:
            print("{0} : 클로킹 모드 설정합니다.".format(self.name))
            self.cloaked = True

# 게임 시작
def game_start():
    print("[알림] 새로운 게임을 시작합니다.")

# 게임 종료
def game_over():
    print("Player : gg") # good game
    print("[Player] 님이 게임에서 퇴장하셨습니다.")

# 실제 게임 진행
game_start()

# 마린 3기 생성
m1 = Marine()
m2 = Marine()
m3 = Marine()

# 탱크 2기 생성
t1 = Tank()
t2 = Tank()

# 레이스 1기 생성
w1 = Wraith()

# 유닛 일괄 관리 (생성된 모든 유닛 append)
attack_units = []
attack_units.append(m1)
attack_units.append(m2)
attack_units.append(m3)
attack_units.append(t1)
attack_units.append(t1)
attack_units.append(w1)

# 전군 이동
for unit in attack_units:
    unit.move("1시")

# 탱크 시즈모드 개발
Tank.siege_developed = True
print("[알림] 탱크 시즈 모드 개발이 완료되었습니다.")

# 공격 모드 준비 (마린 : 스팀팩, 탱크 : 시즈모드, 레이스 : 클로킹)
for unit in attack_units:
    if isinstance(unit, Marine): # Marine 의 인스턴스이면 스팀팩
        unit.stimpack()
    elif isinstance(unit, Tank): # Tank 의 인스턴스이면 시즈모드
        unit.set_siege_mode()
    elif isinstance(unit, Wraith): # Wraith 의 인스턴스이면 클로킹
        unit.cloaking()

# 전군 공격
for unit in attack_units:
    unit.attack("1시")

# 전군 피해
for unit in attack_units:
    unit.damaged(randint(5, 20)) # 공격은 랜덤으로 받음 (5 ~ 20)

# 게임 종료
game_over()



새로운 개념

# 공격 모드 준비 (마린 : 스팀팩, 탱크 : 시즈모드, 레이스 : 클로킹)
for unit in attack_units:
    if isinstance(unit, Marine): # Marine 의 인스턴스이면 스팀팩
        unit.stimpack()
    elif isinstance(unit, Tank): # Tank 의 인스턴스이면 시즈모드
        unit.set_siege_mode()
    elif isinstance(unit, Wraith): # Wraith 의 인스턴스이면 클로킹
        unit.cloaking()

객체의 상속받은 클래스 구분
형태 : isinstance(객체, 클래스) 
True/False 로 출력되며 객체의 클래스 구분 가능해짐

------------------------------------------------------------------------------------------------------------

<예외처리>

에러 처리를 하는것

ex) 계산기
print("나누기 전용 계산기입니다.")
num1 = int(input("첫 번째 숫자를 입력하세요 : "))
num2 = int(input("두 번째 숫자를 입력하세요 : "))
print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))

여기서 숫자가 아닌 문자가 입력되면 에러 발생
=>   File "파일경로", line 3, in <module>
    num2 = int(input("두 번째 숫자를 입력하세요 : "))
ValueError: invalid literal for int() with base 10: '삼'

이런 에러들을 처리하고자 한다.

형태:

try:
    실행 명령문1
    실행 명령문2
    ...
except 에러 종류1:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
except 에러 종류2:
    예외 처리 명령문1
    예외 처리 명령문2
    ...

ex)
try:
    print("나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요 : "))
    num2 = int(input("두 번째 숫자를 입력하세요 : "))
    print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")

출력 (6과 삼 입력)
=>
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 삼
에러! 잘못된 값을 입력하였습니다.


하지만 더 있음
프로그램을 다시 한 번 실행시키고 6 과 0 을 적어보자

나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 0
Traceback (most recent call last):
  File "파일경로", line 5, in <module>
    print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
ZeroDivisionError: division by zero

=>  ZeroDivisionError 가 나오면서 메시지가 출력. 
모든 수는 0 으로 나눌 수 없는데 두 번째 값으로 0 을 넣어서 발생하는 오류

이런 서로 다른 종류의 에러에 대해 각각 처리하려면 except 구문을 추가하여 작성하면 됨

ex)
try:
    print("나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요 : "))
    num2 = int(input("두 번째 숫자를 입력하세요 : "))
    print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)   <---- Error를 err로 전달

출력 => 
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 0
division by zero


마지막줄 err(=ZeroDivisionError)는 무엇일까?
알고 보니 이는 예외처리 전에 발생한 에러 메시지 중 ZeroDivisionError: 뒤에 나오는 메시지가 그대로 출력된 것

**와 같이 에러의 종류에 따라 쉽게 알아볼 수 있는 메시지가 제공되는 경우 
코드에서 별도로 에러 메시지를 정의하지 않고도 간편하게 예외처리 가능


이번에는 코드를 많이 바꿔보자.
 두 개의 수를 입력받는건 동일한데 입력받은 수를 nums 라는 리스트에 추가를 하고 
이어서 계산 결과까지 리스트에 추가한 뒤에 print() 를 통해서 리스트의 값 3개를 순서대로 출력

--만약에 계산 결과를 리스트에 추가하는 부분을 깜빡했다면?

try:
    print("나누기 전용 계산기입니다.")
    nums = []
    nums.append(int(input("첫 번째 숫자를 입력하세요 : ")))
    nums.append(int(input("두 번째 숫자를 입력하세요 : ")))
    # nums.append(int(nums[0] / nums[1])) # 계산 결과를 리스트에 추가    < ------ 이 부분을 주석처리해서 생략시켜줌
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)


==>  이번에는 또 새로운 에러가 발생!

Traceback (most recent call last):
  File "파일경로", line 38, in <module>
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
IndexError: list index out of range

|=> 그 이유는 현재 리스트에는 두 개의 수만 들어있으므로 index 기준으로는 [0], [1] 만 접근 가능한데
 [2] 에 접근하려고 하니 사용 가능한 리스트의 범위를 벗어나서 발생하는 에러


**이번에도 IndexError 구문을 추가할 수도 있겠지만 이런 식으로 모든 에러에 대한 처리를 다 해주기는 어려운 경우도 있다.

|||코드 마지막에 except Exception as err: 구문을 추가함으로써 지금까지 정의되지 않은 모든 에러에 대한 처리가 가능|||


try:
    print("나누기 전용 계산기입니다.")
    nums = []
    nums.append(int(input("첫 번째 숫자를 입력하세요 : ")))
    nums.append(int(input("두 번째 숫자를 입력하세요 : ")))
    # nums.append(int(nums[0] / nums[1])) # 계산 결과를 리스트에 추가
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)
except Exception as err:
    print("알 수 없는 에러가 발생하였습니다.")
    print(err)

출력 =>

나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 3
알 수 없는 에러가 발생하였습니다.
list index out of range

----------------------------------------------------------------------------------------------------------------------------------
<에러 발생시키기>

파이썬에서는 필요에 따라 사용자가 새롭게 에러를 정의하고 그에 대한 예외처리를 할 수 있다.

앞에서 만든 한 자리 숫자 나누기 전용 계산기 프로그램에서 실수로 두 자리 이상의 수를 입력했을 때
 사용자가 입력한 값 중 어떤 값이 잘못되었는지를 보다 자세히 알려주도록 코드를 수정해보자.

먼저 두 자리 이상의 수를 입력해서 발생한 에러라는 의미로 BigNumberError 라는 클래스를 만들고
 파이썬에서 이미 정의되어 있는 Exception 이라는 클래스를 상속받도록 하자.

ex)

class BigNumberError(Exception): # 사용자 정의 에러
    pass

try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10: # 입력받은 수가 한 자리인지 확인
        # raise ValueError
        raise BigNumberError # 사용자 정의 에러
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
except BigNumberError: # 사용자 정의 예외 처리
    print("에러가 발생하였습니다. 한 자리 숫자만 입력하세요.")


출력 => 

한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.


이렇게만 해서는 ValueError 와 큰 차이가 없으므로 이번에는 BigNumberError 의 내용을 채워보자
흐름은,
pass 부분 대신 __init__() 생성자와 __str__() 메소드를 추가. 
생성자(__init__)에서는 에러 메시지를 의미하는 msg 를 전달받아서 멤버변수로 설정하고
, __str__() 메소드에서는 멤버변수 msg 를 반환

ex)
class BigNumberError(Exception): # 사용자 정의 에러
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10: # 입력받은 수가 한 자리인지 확인
        raise BigNumberError("입력값 : {0}, {1}".format(num1, num2)) # 자세한 에러 메시지
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
except BigNumberError as err:
    print("에러가 발생하였습니다. 한 자리 숫자만 입력하세요.")
    print(err) # 에러 메시지 출력


출력 =>
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.    
입력값 : 10, 5

흐름을 보면,
에러가 발생하는 시점에 어떤 값들이 입력되었는지를 문자열 형태로 작성. 
이 내용이 바로 __init__() 생성자의 msg 로 들어가게 된다. 
그리고 except 구문에서는 as 를 이용하여 err 이라는 이름으로 에러를 받고
 이를 print() 를 통해 출력하면 __str__() 메소드에 의해 반환되는 msg 멤버변수가 출력

+ 생성자에서 추가로 어떤 작업을 해야 한다거나 
__str__() 메소드에서 에러 메시지를 에러 코드 등과 함께 출력하고 싶은 경우에 다음과 같이 코드를 수정가능

ex)
class BigNumberError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return "[에러코드 001] " + self.msg # 에러 메시지 가공

출력 =>

[에러코드 001] 입력값 : 10, 5

---------------------------------------------------------------------------------------------------------------------------

<finally>

try 구문을 사용할 때 finally 라는 게 있다. 
finally 는 try 구문 내에서 에러가 발생하건 말건 try 를 벗어나는 시점에 무조건 실행되는 구문. 
finally 는 try 와 except 로 이루어진 구문의 맨 밑에 정의

형태:
try:
    실행 명령문1
    실행 명령문2
    ...
except 에러 종류1:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
except 에러 종류2:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
finally:
    실행 명령문1
    실행 명령문2
    ...

class BigNumberError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

ex)
try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10:
        raise BigNumberError("입력값 : {0}, {1}".format(num1, num2))
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
except BigNumberError as err:
    print("에러가 발생하였습니다. 한 자리 숫자만 입력하세요.")
    print(err)
finally: # 에러 발생 여부 상관 없이 항상 실행
    print("계산기를 이용해 주셔서 감사합니다.")

일부러 에러를 발생시키기 위해 10 과 5 를 순서대로 입력

출력 :

한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.
입력값 : 10, 5
계산기를 이용해 주셔서 감사합니다.

응용
일반적으로 try 구문 내에서 파일이나 자원을 사용한 경우
 finally 구문에서 열린 파일을 닫거나 자원을 해제하는 작업을 수행. 
이렇게 하면 프로그램이 실행되는 과정에서 에러가 발생하고 올바른 예외처리가 되지 않은 경우라도 
항상 자원이 정상적으로 해제되는 것을 보장

----------------------------------------------------------------------------------------------------------------------

<모듈>

함수 정의나 클래스 등 서로 관련이 있거나 
비슷한 기능을 하는 파이썬 문장들을 담고 있는 파일을 모듈(module) 이라고 하며, 
필요한 것들끼리 부품처럼 잘 만드는 것을 모듈화 (modularization) 라고 한다.

앞에서 random 모듈을 가져다가 사용했었음.
난수를 생성하는 함수들이 정의된 random 모듈 덕분에
우리는 별도의 난수 생성 함수를 정의할 필요 없이 random 모듈을 import 하여 사용하기만 하면 되었다.

파이썬 개발을 하다 보면 새로운 모듈을 개발해야 할 필요가 있음.

직접 모듈을 만들어 보자.

ex) 
1. 모듈로 만들 파일생성
2. 같은 경로상의 파일(같은 폴더 내)에서 import 로 이 파일 접근 => 사용 
     or from 파일 import 특정메소드,클래스

파일 이름 theater_module.py 로 지어줌
안의 내용은
# 일반 가격
def price(people):
    print("{0}명 가격은 {1}원 입니다.".format(people, people * 10000))

# 조조 할인 가격
def price_morning(people):
    print("{0}명 조조 할인 가격은 {1}원 입니다.".format(people, people * 6000))

# 군인 할인 가격
def price_soldier(people):
    print("{0}명 군인 할인 가격은 {1}원 입니다. ".format(people, people * 4000))

다음과 같이 만듬

호출( 모듈import 하고 '.'으로 접근)

import theater_module # theater_module 을 가져다가 사용
theater_module.price(3) # 3명이 영화 보러 갔을 때 가격
theater_module.price_morning(4) # 4명이 조조 영화 보러 갔을 때
theater_module.price_soldier(5) # 5명이 군인이 영화 보러 갔을 때


이름이 너무 길면 축약 가능( as 이용 )
import theater_module as mv # theater_module 을 새로운 별명인 mv 로 사용
mv.price(3)
mv.price_morning(4)
mv.price_soldier(5)

from 뒤에 모듈 이름을 적고 그 모듈 내에서 가져다가 사용할 부분을 import 뒤에 적어주면 특정부분 가져옴 가능
모두 가져오려면 "*" 이용
from theater_module import * # theater_module 내에서 모든 것을 가져다가 사용
price(3) # theater_module. 필요 없음
price_morning(4)
price_soldier(5)

특정 메소드 가져와 이름 재정의
from theater_module import price_soldier as price # price_soldier 를 새로운 별명인 price 로 사용
price(5) # price_soldier() 를 호출

------------------------------------------------------------------------------------------------------------------------

<패키지>

파이썬에서는 여러 모듈들을 모아 놓은 집합을 패키지라고 하며,
 패키지는 보통 하나의 폴더 안에 여러 모듈 파일들로 구성

ex) 신규 여행사 관련 프로젝트를 담당하게 되었다고 가정
   이 여행사는 태국과 베트남 패키지 여행 상품을 제공

Visual Studio Code 에서 새로운 폴더를 하나 만들고 이름은 travel 로 하여 새로운 패키지를 생성. 
그리고 travel 폴더 밑에 태국 패키지 상품을 위한 모듈인 thailand.py 파일, 
그리고 베트남 패키지 상품을 위한 모듈인 vietnam.py 파일을 만든다. 마지막으로 __init__.py 라는 파일도 함께 만든다.

travel
 ├  __init__.py
 ├  thailand.py 
 └  vietnam.py

thailand.py 
=>
class ThailandPackage:
    def detail(self):
        print("[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원")

vietnam.py
=>class VietnamPackage:
    def detail(self):
        print("[베트남 패키지 3박 5일] 다낭 효도 여행 60만원")

__init__.py : 그대로 두자.


호출 해보자.

import travel.thailand
trip_to = travel.thailand.ThailandPackage()
trip_to.detail()

****단, import 구문을 사용할 때는 그 대상이 모듈이나 패키지여야 하며, 클래스나 함수는 import 를 할 수 없다.***
 ex ) import travel.thailand.ThailandPackage # 클래스 직접 import 불가

반면에 from ~ import 구문을 사용하면 모듈, 패키지, 클래스, 함수 모두 import 가능

ex)

from travel.thailand import ThailandPackage # travel.thailand 모듈에서 ThailandPackage 클래스 가져오기
trip_to = ThailandPackage() # travel.thailand. 는 생략
trip_to.detail()

베트남도 확인해보자,
from travel import vietnam # travel 패키지에서 vietnam 모듈 가져오기
trip_to = vietnam.VietnamPackage() # travel. 은 생략
trip_to.detail()


*****어떤 대상을 import 하느냐에 따라서 대상 내에 접근하기 위한 코드도 달라져야 한다는 점을 주의*****


---------------------------------------------------------------------------------------------------------------------
<__all__>

 random 모듈을 import 할 때 * 를 사용함으로써 random 모듈 내의 모든 것을 가져다 쓸 수 있다고 공부한 적이 있다.

travel 패키지도 같은 방식으로 해보면
from travel import *
trip_to = vietnam.VietnamPackage() # 베트남
trip_to.detail()

출력 =>> 
NameError: name 'vietnam' is not defined

에러가 뜬다. 
이유 : * 을 쓴다는 것의 의미는 travel 이라는 패키지에 있는 모든 것을 가져다 쓰겠다는 것인데, 
실제로는 패키지를 만든 사람이 공개 범위를 설정해주어야 *를 통해 모두 불러 올 수있다.


travel 패키지를 만들 때 함께 생성했던 __init__.py 을 수정해주자.

__all__ = ["vietnam"] # vietnam 모듈 공개

=> 이러면 실행 된다.

thailand도 공개해주어야 접근 가능
=> __init__.py 
=> __all__ = ["vietnam", "thailand"] # vietnam, thailand 모듈 공개 

를 통해 둘 다 공개

이후

from travel import *
# trip_to = vietnam.VietnamPackage()
trip_to = thailand.ThailandPackage() # 태국
trip_to.detail()

출력 =>

[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원


올바르게 동작한다.


--------------------------------------------------------------------------------------------------------------------------

< 모듈 직접 실행 >

모듈이 직접 실행되는지, 아니면 별도의 파일에서 호출되어 실행되는지를 구분하는 방법

if __name__ == "__main__": # 직접 실행되는 경우
    pass
else: # 외부에서 호출되어 실행되는 경우
    pass

앞에서 만든 travel 패키지의 thailand.py 파일에서 ThailandPackage 클래스 정의부분 밑에 코드를 추가해보자.
 if 구문을 통해 __name__ 이 "__main__" 인 경우,
 즉 이 모듈이 직접 실행되는 경우에는 출력문과 함께 ThailandPackage 객체를 만들어서 
detail() 메소드를 호출하는 작업까지 해보자.
 else 구문에서는, 즉 모듈이 외부에서 호출되는 경우에는 
외부에서 호출된다는 문구만 간략히 출력해보자.

ex)

class ThailandPackage:
    def detail(self):
        print("[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원")
        
if __name__ == "__main__": # 모듈 직접 실행
    print("Thailand 모듈을 직접 실행")
    print("이 문장은 모듈을 직접 실행할 때만 실행돼요")
    trip_to = ThailandPackage()
    trip_to.detail()
else: # 외부에서 모듈 호출
    print("Thailand 외부에서 모듈 호출")


1. thailand.py 파일을 연 상태에서 실행 버튼을 클릭
출력
=> 
Thailand 모듈을 직접 실행
이 문장은 모듈을 직접 실행할 때만 실행돼요
[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원

==>  if 조건에 해당하는 구문이 실행되었음


2. 앞 장에서 작성한 내용 그대로 practice.py 파일에서 thailand 모듈을 가져다 써보도록하자.

from travel import *
trip_to = thailand.ThailandPackage()
trip_to.detail()

출력
=>
Thailand 외부에서 모듈 호출
[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원

==> thailand 모듈 내에 정의된 else 구문의 문장이 실행되고 나서 detail() 메소드의 동작이 실행되었음


결론:

if __name__ == "__main__": 구문을 잘 활용하면 모듈을 직접 실행하는지, 
또는 외부에서 가져다 쓰는지를 구분하여 필요한 코드를 작성 할 수 있다.


////////궁금증////////////////
 __name__ 이란 무엇일까?
(해결 : https://lovelydiary.tistory.com/297 )

일단 모듈을 직접 실행 할 때 __name__ 은 "__main__" 를 지닌다.
외부에서 무듈을 호출한다면? =>  else 부분에 print(__name__)을 추가하여 출력해보니 => "travel.thailand" 를 지닌다는 것을 확인하였음


결론 
=> __name__ : 파이썬의 내장변수 혹은 글로벌 변수 (파이썬에 이미 존재하는 변수)

-> 해당 파일 내에서 파일을 실행시키면 __name__ 이라는 변수에 __main__이 담기고,
    해당 파일 외부에서 import 를 통해 파일을 실행시면 __name__이라는 변수에 그 모듈의 이름이 담긴다.(위에서는 모듈 이름이 travel.thailand 였음,(패키지에서 모듈 접근하였으므로))

-------------------------------------------------------------------------------------------------------------------

<패키지, 모듈 위치>

import inspect
import random
print(inspect.getfile(random)) # random 모듈의 위치

inspect를 이용해 모듈 위치를 찾을 수 있다.
출력 =>

C:\Python38\lib\random.py


이번에는 우리가 만든 travel 패키지의 thailand 모듈이 어느 경로에 위치하는지 확인

import inspect
from travel import *
print(inspect.getfile(thailand)) # thailand 모듈의 위치

출력=>

Thailand 외부에서 모듈 호출
c:\Users\Nadocoding\Desktop\PythonWorkspace\travel\thailand.py

앞에서 패키지나 모듈은 "파이썬 라이브러리들이 모여 있는 폴더" 에 있으면 사용 가능했다.
 travel 패키지 폴더를 lib 폴더로 복사

=> 이후 복사하고 다시 파일 위치 확인
Thailand 외부에서 모듈 호출
c:\Python38\lib\travel\thailand.py

==> 호출하려는 파일과 같은 경로가 아닌 파이썬 설치 경로의 lib 폴더에 있는 패키지를 사용한 것이며, 
이는 새로운 파이썬 프로젝트를 생성하여 작업을 할 때도 동일하게 travel 패키지를 가져다 쓸 수 있다는 의미


--------------------------------------------------------------------------------------------------------------------------
<pip install>
 pypi.org 에서 패키지 검색 후 
pip install (패키지 이름) 을 통해 설치

여러 pip 동작
install		패키지 설치	pip install [패키지]
install --upgrade	패키지 업그레이드	pip install --upgrade [패키지]
uninstall		패키지 삭제	pip uninstall [패키지]
list		설치 패키지 목록	pip list
show		패키지 상세 정보	pip show [패키지]


+ windows에서 pip 설치
cmd에서
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py.
python get-pip.py.


+ 세부 내용
https://nadocoding.tistory.com/82?category=902275

------------------------------------------------------------------------------------------------------------------------

<내장 함수>

파이썬에는 내장 함수 (built-in function) 가 있다. 
내장 함수란 별도로 import 를 하지 않고도 사용할 수 있도록 내장되어 있는 함수. 
사용자의 입력을 받기 위한 input() 함수도 내장 함수 중 하나

내장 함수는 종류가 굉장히 많은데 그 중 하나인 dir() 함수를 실습해보자.

dir() 은 어떤 객체를 넘겼을 때 그 객체가 어떤 변수와 함수를 가지고 있는지 알려주는 목적으로 사용.
 만약 전달값으로 아무것도 넘기지 않는다면 현재 소스코드 범위 내에서 사용 가능한 모듈 또는 객체가 출력됨

print(dir())
import random # random 모듈 가져다 쓰기
print(dir())
import pickle # pickle 모듈 가져다 쓰기
print(dir())

출력=>
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'random']
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'pickle', 'random']

=>실행시켜보니 처음에는 기본 값들만 출력되고 import random 다음에는 random 모듈이, import pickle 다음에는 pickle 모듈이 포함되어 코드 내에서 사용할 수 있음을 확인가능


파이썬에서 제공되는 내장 함수에 대한 더 자세한 내용은 구글에서 "list of python builtins" 로 검색을 하면 나오는 파이썬 공식 홈페이지의 Built-in Functions 페이지에 방문하여 확인가능
(https://docs.python.org/3/library/functions.html)
참고로 ,좌측 상단의 언어 설정 (기본값 : English) 부분을 클릭하면 한국어 (Korean) 로 번역된 페이지를 확인가능

+ 각 내장 함수를 클릭해보면 설명을 확인할 수 있으며 예제 코드가 함께 제공되는 경우도 있음.

-----------------------------------------------------------------------------------------------------------------------------------

<외장함수>

내장 함수와는 다르게 외장 함수를 사용하기 위해서는 반드시 해당 모듈을 import 해야한다.
 먼저 파이썬에서 제공되는 모듈을 살펴보기 위해 구글에서 "list of python modules" 로 검색

식 홈페이지의 Python Module Index 페이지를 방문하면 파이썬에서 사용할 수 있는 모듈 목록이 알파벳 순으로 정렬되어 나오며 모듈을 선택하면 사용 가능한 함수들에 대해 설명 및 예제 코드를 확인 가능


모듈 페이지에서 모듈 하나를 클릭해서 들어가면
상단에 요약 정보와 파이썬 설치 경로 내의 파일 위치 (Lib/random.py) 가 표시되며, 
이어서 모듈에 대한 자세한 설명이 제공됩니다. 스크롤을 조금 더 내리면 모듈 내에서 사용 가능한 함수들 및 예제 코드를 확인 가능

모듈은 굉장히 유용하면서도 그 수가 많기 때문에 어떤 것들이 있는지 많이 알면 알수록 유리하지만 
모두 외울 수는 없으므로 한 번쯤 모듈 이름 정도는 훑어보시는 편이 좋음


실습을 위해 자주 사용되는 몇 가지 모듈을 사용해보자.

ex)
처음 사용할 모듈은 glob .
 glob 은 어떤 경로 내의 폴더 또는 파일의 목록을 조회할 때 사용하며 윈도우에서는 dir 명령과 비슷.
 glob 모듈에는 glob() 이라는 함수가 있는데 파일 이름 또는 형태를 넘기면 그에 해당하는 파일이 조회된다.
 예제 코드에서는 import 를 통해 glob 모듈을 가져다 쓰도록 하고
 glob() 함수에는 모든 것을 의미하는 * 와 
파이썬 파일 확장자를 의미하는 .py 를 합친 *.py 를 전달함으로써 
확장자가 py 인 모든 파일의 목록을 출력해보자.

import glob
print(glob.glob("*.py")) # 확장자가 py 인 모든 파일

출력=>

['helloworld.py', 'practice.py', 'theater_module.py']  <= 현재 폴더 내의 .py 확장자의 모든 파일



ex)
다음으로 사용할 모듈은 os . 
os 는 운영체제에서 제공하는 기본 기능 정도로 생각하면 됨.
 예를 들어서 폴더를 만들거나 삭제하는 기능을 수행 가능.
 우선 현재 파이썬 파일이 실행되는 디렉토리 정보를 출력하는 간단한 코드를 작성해보자.
 os 모듈을 import 하고 getcwd() 함수를 호출하는데
 이 때 cwd 는 current working directory 로 현재 작업 디렉토리를 의미한다.

import os
print(os.getcwd()) # 현재 디렉토리

출력=>
C:\Users\사용자이름\현재 폴더 위치


ex)
이번에는 폴더를 하나 만들어보자.
 folder 변수에 "sample_dir" 이란 값을 지정하고, 
os 모듈이 제공하는 기능 중 주어진 경로에 해당하는 폴더 또는 파일이 존재하는지 여부를 알려주는 os.path.exists() 함수를 통해서
 folder 변수와 동일한 이름의 폴더가 존재하는지를 확인. 
확인 결과,
폴더가 존재하지 않는 경우에만 makedirs() 함수를 통해서 새로운 폴더를 생성.

import os

folder = "sample_dir"

if os.path.exists(folder): # 폴더가 존재한다면
    print("이미 존재하는 폴더입니다.")
else: # 폴더가 존재하지 않으면
    os.makedirs(folder) # 폴더 생성
    print(folder, "폴더를 생성하였습니다.")


프로그램을 실행시켜보면 Visual Studio Code 좌측 EXPLORER 탭에 sample_dir 이라는 폴더가 새로 생기고
 다음 문장이 출력되는 것을 확인 가능 => sample_dir 폴더를 생성하였습니다.
다시 한 번 프로그램을 실행시키면 이미 sample_dir 폴더가 존재하기 때문에 출력 결과는 달라짐 => 이미 존재하는 폴더입니다.


폴더가 존재하는 경우 해당 폴더를 삭제하도록 if 구문을 조금 수정해보자. 
os 모듈의 rmdir() 함수를 이용하여 folder 변수를 전달하면 되는데 
이 때 rm 은 삭제를 의미하는 remove 의 줄임말이다.

import os

folder = "sample_dir"

if os.path.exists(folder):
    print("이미 존재하는 폴더입니다.")
    os.rmdir(folder) # 폴더 삭제
    print(folder, "폴더를 삭제하였습니다.") # 삭제 문구 출력
else:
    os.makedirs(folder)
    print(folder, "폴더를 생성하였습니다.")


ex)
os 가 제공하는 함수 중에 listdir() 이라는 것이 있는데, glob 모듈의 glob() 함수와 비슷하게
 현재 작업 디렉토리 내의 폴더와 파일 목록을 출력해줌

import os
print(os.listdir())


ex)
이번에는 시간 관련 함수를 제공하는 time 모듈을 사용해본다.
time 모듈을 import 하고 나서 현재 시간 정보를 확인하기 위한 localtime() 함수를 호출

import time
print(time.localtime())

출력 =>
time.struct_time(tm_year=2022, tm_mon=1, tm_mday=26, tm_hour=18, tm_min=7, tm_sec=36, tm_wday=2, tm_yday=26, tm_isdst=0)

**우리나라는 날짜 정보를 보통 "2021년 10월 1일"과 같이 연/월/일 순으로 작성하는데, 
국가에 따라 일/월/년 또는 월/일/년 등으로 순서를 다르게 표시하는 경우도 있다.
 time 모듈에는 strftime() 함수를 제공하는데 이를 이용하면 
사용자가 원하는 문자열 형태로 시간 정보를 출력 가능

이 때 주로 사용되는 코드와 의미
코드	의미
%Y	년 (year)
%m	월 (month)
%d	일 (day)
%H	시 (hour)
%M	분 (minute)
%S	초 (second)

////가령 날짜와 시간 정보를 "2021-10-01 22:00:00" 와 같이 출력하려면 
////각 자리에 맞게 코드를 입력하고 코드들 사이에 하이픈 (-) 과 콜론 (:) 을 적절히 배치하는 식으로 작성할 수 있다. 
////이 때 코드는 대소문자를 구분하므로 주의해서 사용해야 한다.


import time
print(time.strftime("%Y-%m-%d %H:%M:%S")) # 연-월-일 시:분:초

출력 => 2022-01-26 18:11:16

+ time 과 비슷한 모듈로 datetime 도 있다. datetime 을 활용하여 오늘 날짜를 출력하려면 다음과 같이 할 수 있다.
import datetime
print("오늘 날짜는", datetime.date.today())

출력 => 오늘 날짜는 2021-10-01

datetime 에는 timedelta() 라는 함수가 있는데 이 함수를 이용하면 두 날짜 사이의 간격을 쉽게 계산할 수 있습니다.

만약 오늘 누군가를 만나기 시작했고 오늘로부터 100 일째 되는 날을 계산한다고 가정. 
먼저 오늘 날짜 정보를 저장하기 위해 앞 예제에서 했던 것처럼 datetime.date.today() 함수를 호출하여
 today 라는 변수에 저장. 
그리고 100 일 뒤를 계산하기 위해 timedelta() 함수를 호출하면서
일별 계산을 하기 위해 days 라는 키워드 인자에 100 을 넣고 반환되는 값을 td 변수에 저장. 
마지막으로 print() 함수를 통해 today 와 td 를 더한 값을 출력한다.

import datetime
today = datetime.date.today() # 오늘 날짜 저장
td = datetime.timedelta(days=100) # 100일 저장
print("우리가 만난지 100일은", today + td) # 오늘부터 100일 후

출력 =>
우리가 만난지 100일은 2022-01-09

+ 추가
100 days, 0:00:00 : td 내에 저장된 값
2022-01-26 : today 내에 저장된 값

파이썬으로 개발을 할 때 처음부터 끝까지 모든 기능을 직접 구현하려고 하지 말고, 
구글링을 통해 이미 누군가가 잘 만들어 놓은 유용한 라이브러리 (패키지, 모듈) 를 찾아보는 것을 권한다.

여러분이 필요로 하는 대부분의 라이브러리는 이미 존재하고 있으며 지금 이 시간에도 새로운 라이브러리들이 만들어지고 있다.
나에게 꼭 필요한 라이브러리를 잘 찾아서 프로젝트에 적용하는 것은 뛰어난 개발자의 덕목이자 개발 생산성을 눈에 띄게 향상시킬 수 있는 훌륭한 전략이다.


---------------------------------------------------------------------------------------------------------------------------------